#!/bin/bash
#
# rebuild_hosts: generate /etc/hosts from /etc/hosts.d fragments.
#
# Each file in /etc/hosts.d/ should contain lines in standard hosts(5) format:
#   IPADDR  hostname [alias...]
#
# This script:
#   - Reads all regular files in /etc/hosts.d, in sorted order,
#     with a special case: a fragment named "_base" is always processed first
#       (typically generated by rc.S.cont to define the hostname + loopbacks).
#   - Merges entries with the same IP onto a single line.
#   - Deduplicates hostnames per IP.
#   - Tracks which fragments contributed to each IP and annotates with '# from ...'.
#   - Ensures minimal localhost entries exist (127.0.0.1 / ::1) if no fragments exist.
#   - Logs a warning if a hostname is associated with multiple IPs in the same family.
#   - Writes the result atomically to /etc/hosts with perms root:root 0644.
#
# Do NOT edit /etc/hosts directly; edit /etc/hosts.d/* instead.

set -euo pipefail

# run & log functions
. /etc/rc.d/rc.runlog

trap 'log "rebuild_hosts FAILED with status $? (see previous log lines for context)"' ERR

HOSTS_DIR=/etc/hosts.d
HOSTS_FILE=/etc/hosts

# Create temp file in same FS as HOSTS_FILE so mv is atomic
tmpfile=$(mktemp "${HOSTS_FILE}.XXXXXX")

# Header
{
  echo "# $HOSTS_FILE - automatically generated by rebuild_hosts"
  echo "# Do not edit this file directly; use ${HOSTS_DIR}/* instead."
  echo "#"
  echo "# fragments:"
  shopt -s nullglob
  for f in "$HOSTS_DIR"/*; do
    [ -f "$f" ] || continue
    printf "#   %s\n" "$(basename "$f")"
  done
  shopt -u nullglob
  echo
} >"$tmpfile"

# IP -> "host1 host2 ..."
declare -A IP_TO_HOSTS

# IP -> "fragment1 fragment2 ..."
declare -A IP_TO_SOURCES

# Hostname -> "ip1 ip2 ..." (tracked separately for IPv4 and IPv6)
declare -A HOST_TO_IPS_V4
declare -A HOST_TO_IPS_V6

# Preserve IP order (first time we see an IP, record it here)
IP_ORDER=()

# Name of the fragment currently being processed (basename of file)
CURRENT_SOURCE=""

add_hosts_line() {
  # $1 = IP address, remaining args = hostnames/aliases
  local ip="$1"; shift
  local host

  # If this IP hasn't been seen yet, initialize it and record order
  if [[ -z "${IP_TO_HOSTS[$ip]+x}" ]]; then
    IP_TO_HOSTS["$ip"]=""
    IP_ORDER+=("$ip")
  fi

  # Append any new hostnames for this IP, skipping duplicates.
  # We store hostnames as a space-separated string.
  local current_hosts="${IP_TO_HOSTS[$ip]}"

  # Determine IP family once (simple heuristic: ':' means IPv6)
  local family
  family=$([[ "$ip" == *:* ]] && echo v6 || echo v4)

  # Iterate over all hostnames passed to this function
  for host in "$@"; do
    # Skip empty tokens (paranoia / defensive programming)
    [[ -z "$host" ]] && continue

    # Check if this hostname is already present for this IP.
    # We wrap the string and hostname with spaces so we can do
    # a simple substring match without false positives:
    #   " foo bar " contains " bar " but not " ar ".
    case " $current_hosts " in
      *" $host "*) ;;                      # already present, do nothing
      *) current_hosts="$current_hosts $host" ;;  # append new hostname
    esac

    # Track IPs per hostname for duplicate detection
    if [[ "$family" == "v4" ]]; then
      local ips_v4="${HOST_TO_IPS_V4[$host]:-}"
      case " $ips_v4 " in
        *" $ip "*) ;;                     # already recorded for this host
        *) ips_v4="$ips_v4 $ip" ;;
      esac
      HOST_TO_IPS_V4["$host"]="${ips_v4# }"
    else
      local ips_v6="${HOST_TO_IPS_V6[$host]:-}"
      case " $ips_v6 " in
        *" $ip "*) ;;
        *) ips_v6="$ips_v6 $ip" ;;
      esac
      HOST_TO_IPS_V6["$host"]="${ips_v6# }"
    fi
  done

  # Strip the leading space if we added anything
  IP_TO_HOSTS["$ip"]="${current_hosts# }"

  # Track which fragment files contributed to this IP.
  # This is just for the trailing "# from _base avahi builtin" comment.
  if [[ -n "$CURRENT_SOURCE" ]]; then
    local current_sources="${IP_TO_SOURCES[$ip]:-}"
    case " $current_sources " in
      *" $CURRENT_SOURCE "*) ;;
      *) current_sources="$current_sources $CURRENT_SOURCE" ;;
    esac
    IP_TO_SOURCES["$ip"]="${current_sources# }"
  fi
}

process_file() {
  local file="$1"
  local line ip

  # Remember which fragment we are processing for source tracking
  CURRENT_SOURCE="$(basename "$file")"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Strip comments (anything after '#')
    line="${line%%#*}"

    # Trim leading and trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip empty lines
    [[ -z "$line" ]] && continue

    # Split line into fields:
    #   $1 = IP, remaining = hostnames/aliases.
    # shellcheck disable=SC2086
    set -- $line
    ip="$1"; shift || true

    # If IP is empty or no hostnames, skip the line
    [[ -z "$ip" ]] && continue
    [[ $# -eq 0 ]] && continue

    add_hosts_line "$ip" "$@"
  done <"$file"
}

check_duplicate_hostnames() {
  local host ips

  # IPv4 duplicates
  for host in "${!HOST_TO_IPS_V4[@]}"; do
    ips="${HOST_TO_IPS_V4[$host]}"
    # Count how many distinct IPs this hostname maps to
    set -- $ips
    if (( $# > 1 )); then
      log "Warning: hostname '$host' appears on multiple IPv4 addresses: $ips"
    fi
  done

  # IPv6 duplicates
  for host in "${!HOST_TO_IPS_V6[@]}"; do
    ips="${HOST_TO_IPS_V6[$host]}"
    set -- $ips
    if (( $# > 1 )); then
      log "Warning: hostname '$host' appears on multiple IPv6 addresses: $ips"
    fi
  done
}

log "Rebuilding $HOSTS_FILE..."

# Collect fragment files (simple glob) and force _base first if present
shopt -s nullglob
all_files=("$HOSTS_DIR"/*)
shopt -u nullglob

fragment_files=()

# Force the core base fragment first if it exists
if [[ -f "$HOSTS_DIR/_base" ]]; then
  fragment_files+=("$HOSTS_DIR/_base")
fi

# Then add all other fragments in normal glob order
for f in "${all_files[@]}"; do
  # Skip _base if we already added it
  [[ "$f" == "$HOSTS_DIR/_base" ]] && continue
  [[ -f "$f" ]] || continue
  fragment_files+=("$f")
done

# Process each fragment
for f in "${fragment_files[@]}"; do
  [[ -f "$f" ]] || continue
  process_file "$f"
done

# If no fragments defined any IPs at all, provide a minimal fallback
CURRENT_SOURCE="builtin"
if (( ${#IP_ORDER[@]} == 0 )); then
  add_hosts_line "127.0.0.1" "localhost"
  add_hosts_line "::1"       "localhost"
fi

# Warn about hostnames bound to multiple IPs (per family)
check_duplicate_hostnames

# Emit merged lines in original IP discovery order
for ip in "${IP_ORDER[@]}"; do
  hosts="${IP_TO_HOSTS[$ip]}"
  sources="${IP_TO_SOURCES[$ip]:-}"

  if [[ -n "$sources" ]]; then
    printf "%-15s %s    # from %s\n" "$ip" "$hosts" "$sources" >>"$tmpfile"
  else
    printf "%-15s %s\n" "$ip" "$hosts" >>"$tmpfile"
  fi
done

# Set perms and atomic replace
chmod 0644 "$tmpfile" 2>/dev/null || true
chown root:root "$tmpfile" 2>/dev/null || true
mv "$tmpfile" "$HOSTS_FILE"

# Summary log: how many IPs and how many fragments contributed
log "${#IP_ORDER[@]} merged IP entries from ${#fragment_files[@]} contributing fragments written to $HOSTS_FILE"
